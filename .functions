#!/bin/bash

# cd
function cd() {
	builtin cd "$@" && ls
}

# Define color and formatting codes
bold=$(tput bold)
underline=$(tput smul)
reset=$(tput sgr0)
red=$(tput setaf 1)
green=$(tput setaf 2)
blue=$(tput setaf 4)

# Make a local git repo and prepare for linking it to a new GitHub repo
function mkgit() {
    # Ask for the directory name
    echo -n "${bold}${blue}Please enter the directory name: ${reset}"
    read directory
    if test -d "$directory"; then
        echo "${bold}${red}Error: folder already exists.${reset}"
        return 1
    fi

    # Make sure this is running in the Documents folder
    if ! [[ "$(pwd)" =~ ~/Documents.*$ ]]; then
        echo "${bold}${red}Error: please navigate to the documents folder before running this script.${reset}"
        return 1
    fi

    # Create a local directory
    mkdir "$directory"
    cd "$directory" || return

    # Ask for repository visibility (public or private)
    echo -n "${bold}${blue}Should the repository be public or private? (public/private)${reset} "
    read visibility
    while [[ "$visibility" != "public" && "$visibility" != "private" ]]; do
        echo "${bold}${red}Invalid input. Please enter either 'public' or 'private'.${reset}"
        read visibility
    done

    # Ask for contents of README
    echo -n "${bold}${blue}What would you like the README to say?${reset} "
    read readme_content
    echo "$readme_content" > README.md

    # Ask for files/directories to ignore
    echo ".vscode/" >> .gitignore

    # Ask for vscode settings
    echo -n "${bold}${blue}Would you like to add a .vscode/settings.json file? (yes/no)${reset} "
    read vscode_answer
    while [[ "$vscode_answer" != "yes" && "$vscode_answer" != "no" ]]; do
        echo "${bold}${red}Invalid input. Please enter either 'yes' or 'no'.${reset}"
        read vscode_answer
    done

    if [ "$vscode_answer" = "yes" ]; then
        mkdir ".vscode"
        (cd ".vscode" || return
        touch settings.json)
    fi

    # Initialize local git repo
    if ! command -v git &> /dev/null; then
        echo "${bold}${red}Git could not be found. Please install it before proceeding.${reset}"
        return 1
    fi

    git init -b main
    git add .
    git commit -m "Initial commit"

    # Prepare for linking local repo to GitHub
    if ! command -v gh &> /dev/null; then
        echo "${bold}${red}GitHub CLI could not be found. Please install it before proceeding.${reset}"
        return 1
    fi

    if gh repo create "$directory" --source=. --remote=upstream --push --${visibility}; then
        echo "${bold}${green}Created the repo $directory on GitHub!${reset}"
    else
        echo "${bold}${red}Failed to create the GitHub repo. Please check your network connection and try again.${reset}"
        return 1
    fi
}

# Create a new python3 virtual environment
function mkvenv() {
    python3 -m venv venv
    source venv/bin/activate
    pip install --upgrade pip
}

# Run stable diffusion locally
# function generate() {
#     # Navigate to stable-diffusion repo
#     cd ~/Documents/code/ml/stable-diffusion
#     source venv/bin/activate

#     python scripts/txt2img.py --prompt "'$*'" --n_samples 1 --n_iter 1 --plms --precision full

#     # Open the latest image
#     cd outputs/txt2img-samples
#     open $(ls -p | grep -v / | tail -1)
# }

# Refresh dotfiles repo
function refresh_dots() {
    # Go to root
    cd ~

    # Refresh Brewfile
    rm Brewfile
    HOMEBREW_NO_AUTO_UPDATE=1 brew bundle dump

    # Copy main dotfiles
    cp .bash_prompt .bash_profile .bashrc .aliases .exports .functions .gitconfig .gitignore_global .git-completion.bash .hushlogin .inputrc .vimrc Brewfile .tmux.conf Documents/code/dotfiles

    # VSCode
    cp ~/Library/Application\ Support/Code/User/{settings.json,keybindings.json} Documents/code/dotfiles/vscode
    cp -R ~/Library/Application\ Support/Code/User/snippets Documents/code/dotfiles/vscode
    cp ~/.vscode/extensions/extensions.json Documents/code/dotfiles/vscode

    # Go to dotfiles folder
    cd ~/Documents/code/dotfiles
}

# Make a new function that converts pdfs to text when you cat them
function catpdf() {
    # Check if the first argument is a PDF file
    if ! [[ "$1" == *.pdf ]]; then
        echo "Error: you must pass in a PDF file."
    fi

    pdftotext "$1"
    cat "${1/.pdf/.txt}"
    rm "${1/.pdf/.txt}"
}

# Refresh a Markdown file on a timer
function rendermd() {
    # Check if the input file has a .md extension
    if [[ "$1" != *.md ]]; then
        echo "Error: input file must have a .md extension."
        return 1
    fi

    # Keep calling the glow command to rerender the file until user is done
    while true; do
        clear && printf '\e[3J' # clear scrollback buffer
        sed 's/->/\&rarr;/g' "$1" > _rendering.md # add fancy arrows for rendering
        glow "_rendering.md"
        sleep 5
    done
    rm _rendering.md
}

# SSHGo - SSH into accounts without memorizing hostnames
function sshgo() {
    # Define the colors and styles using ANSI escape codes
    local RED="\033[31m"
    local GREEN="\033[32m"
    local YELLOW="\033[33m"
    local CYAN="\033[36m"
    local BOLD="\033[1m"
    local RESET="\033[0m"

    # Define your SSH accounts as indexed arrays
    local labels=("1" "2") # Labels for each account
    local descriptions=("Compling GPU Cluster" "Digital Ocean") # Descriptions for each account
    local commands=("irs428@compling.la.utexas.edu" "root@178.128.135.139") # SSH commands

    # Print a pretty list of your SSH accounts
    echo -e "${GREEN}${BOLD}SSH Accounts:${RESET}"
    echo -e "${CYAN}-------------${RESET}"
    for i in "${!labels[@]}"; do
        echo -e "[${YELLOW}${BOLD}${labels[$i]}${RESET}] ${CYAN}${descriptions[$i]}${RESET}"
    done
    echo -e "${CYAN}-------------${RESET}"

    # Prompt the user to select an account
    read -p "Enter the number corresponding to the account you want to SSH into: " selection

    # Check if the entered number is valid
    if [[ ! " ${labels[@]} " =~ " ${selection} " ]]; then
        echo -e "${RED}Invalid selection. Please try again.${RESET}"
        return 1
    fi

    # Find the index of the selected label
    local index
    for i in "${!labels[@]}"; do
        if [[ "${labels[$i]}" == "${selection}" ]]; then
            index="$i"
            break
        fi
    done

    # Copy computer password into clipboard
    echo $COMPUTER_PASSWORD | pbcopy

    # SSH into the selected account
    echo -e "${GREEN}Connecting to ${descriptions[$index]}...${RESET}"
    ssh ${commands[$index]}
}

# From swyx: functions to measure time per bash command
preexec() {
  timer=$(gdate +%s.%N)
}

precmd() {
  if [ -n "$timer" ]; then
    now=$(gdate +%s.%N)
    elapsed=$(echo "$now - $timer" | bc)
    timer_show=$(printf "%.2f" $elapsed)
    echo "Execution time: ${timer_show}s"
    unset timer
  fi
}
